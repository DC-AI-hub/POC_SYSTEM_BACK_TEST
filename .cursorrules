# 港交所POC系统后端开发规则

## 项目概述
您正在开发一个港交所POC系统的Spring Boot后端，主要功能包括费用管理、审批工作流、人员管理等模块。

## 技术栈
- **后端框架**: Spring Boot 2.7.18
- **数据库**: PostgreSQL 13+ (远程部署)
- **ORM**: JPA/Hibernate
- **构建工具**: Maven
- **API文档**: Swagger/OpenAPI
- **安全**: Spring Security + JWT
- **前端**: Next.js 15.2.4 + React 19 + TypeScript

## 数据库环境
```properties
# 生产数据库配置（已部署可用）
spring.datasource.url=jdbc:postgresql://1.15.34.167:5432/hkex_poc
spring.datasource.username=hkex_user
spring.datasource.password=hkex_password_2024
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=update
```

## 项目结构规范
```
demo.backed/
├── controller/      # REST控制器
├── service/         # 业务逻辑层
├── repository/      # 数据访问层
├── entity/          # JPA实体类
├── dto/             # 数据传输对象
├── config/          # 配置类
├── exception/       # 自定义异常
└── util/           # 工具类
```

## 开发规范

### 1. 实体类规范
- 所有表名以 `t_poc_` 开头
- 继承 `BaseEntity` 基类
- 使用 `@Entity` 和 `@Table` 注解
- 主键使用 `@Id` 和 `@GeneratedValue`
- 包含审计字段（创建时间、更新时间、创建人、更新人）

示例：
```java
@Entity
@Table(name = "t_poc_users")
@Data
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity {
    @Column(name = "employee_id", unique = true)
    private String employeeId;
    
    @Column(name = "user_name", nullable = false)
    private String userName;
    
    // 其他字段...
}
```

### 2. Repository规范
- 继承 `JpaRepository<Entity, Long>`
- 使用方法名查询或 `@Query` 注解
- 支持分页和排序

示例：
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.department = :dept AND u.status = '在职'")
    Page<User> findActiveUsersByDepartment(@Param("dept") String department, Pageable pageable);
}
```

### 3. Service规范
- 使用 `@Service` 注解
- 实现业务逻辑和事务管理
- 使用 `@Transactional` 处理事务
- 返回 DTO 而非实体对象

示例：
```java
@Service
@Transactional
@Slf4j
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    public UserDTO createUser(UserDTO userDTO) {
        // 业务逻辑验证
        validateUserData(userDTO);
        
        // 实体转换
        User user = convertToEntity(userDTO);
        
        // 保存并返回
        User savedUser = userRepository.save(user);
        return convertToDTO(savedUser);
    }
}
```

### 4. Controller规范
- 使用 `@RestController` 和 `@RequestMapping`
- RESTful API设计
- 统一响应格式 `ApiResponse<T>`
- 添加 Swagger 注解

示例：
```java
@RestController
@RequestMapping("/api/users")
@Api(tags = "用户管理")
@Slf4j
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping
    @ApiOperation("获取用户列表")
    public ApiResponse<Page<UserDTO>> getUsers(
            @PageableDefault(size = 10) Pageable pageable) {
        Page<UserDTO> users = userService.findAll(pageable);
        return ApiResponse.success(users);
    }
    
    @PostMapping
    @ApiOperation("创建用户")
    public ApiResponse<UserDTO> createUser(@Valid @RequestBody UserDTO userDTO) {
        UserDTO created = userService.createUser(userDTO);
        return ApiResponse.success(created, "用户创建成功");
    }
}
```

### 5. 统一响应格式
```java
@Data
@Builder
public class ApiResponse<T> {
    private int code;           // 状态码
    private String message;     // 消息
    private T data;            // 数据
    private long timestamp;    // 时间戳
    
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .code(200)
                .message("success")
                .data(data)
                .timestamp(System.currentTimeMillis())
                .build();
    }
    
    public static <T> ApiResponse<T> error(String message) {
        return ApiResponse.<T>builder()
                .code(500)
                .message(message)
                .timestamp(System.currentTimeMillis())
                .build();
    }
}
```

### 6. 异常处理
- 使用 `@RestControllerAdvice` 全局异常处理
- 自定义业务异常
- 返回统一错误格式

示例：
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ApiResponse<Void> handleBusinessException(BusinessException e) {
        log.error("业务异常: {}", e.getMessage());
        return ApiResponse.error(e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    public ApiResponse<Void> handleException(Exception e) {
        log.error("系统异常", e);
        return ApiResponse.error("系统异常，请稍后重试");
    }
}
```

### 7. DTO设计规范
- 使用 `@Data` 注解（Lombok）
- 添加验证注解（`@NotNull`, `@Size` 等）
- 与前端数据格式保持一致

示例：
```java
@Data
public class UserDTO {
    private Long id;
    
    @NotBlank(message = "工号不能为空")
    private String employeeId;
    
    @NotBlank(message = "用户名不能为空")
    @Size(max = 50, message = "用户名长度不能超过50")
    private String userName;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    
    // 其他字段...
}
```

## 核心功能模块

### 用户管理模块
- 用户CRUD操作
- JWT认证登录
- 在线用户管理
- 权限控制

### 组织架构模块
- 部门管理（t_poc_departments）
- 岗位管理（t_poc_positions）
- 组织关系（t_poc_organization_relations）
- 树形结构展示

### 费用申请模块
- 费用申请单（t_poc_expense_applications）
- 费用明细（t_poc_expense_items）
- 申请编号生成（EXP-YYYY-XXXXXX）
- 状态管理（草稿、待审批、已通过、已拒绝）

### 工作流模块
- 工作流实例（t_poc_workflow_instances）
- 工作流节点（t_poc_workflow_nodes）
- 8个审批节点流转
- 打回和代理人机制

### 审计日志模块
- 操作日志记录（t_poc_audit_logs）
- AOP切面自动记录
- 日志查询和导出

## 与前端集成要点

### 1. 跨域配置
确保 `SecurityConfig` 中配置了 CORS：
```java
http.cors().configurationSource(request -> {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
    config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    config.setAllowedHeaders(Arrays.asList("*"));
    config.setAllowCredentials(true);
    return config;
});
```

### 2. 日期时间格式
统一使用 ISO 8601 格式：
```java
@JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
private LocalDateTime createdTime;
```

### 3. 分页响应格式
与前端 `Page` 接口保持一致：
```json
{
  "content": [...],
  "totalElements": 100,
  "totalPages": 10,
  "number": 0,
  "size": 10
}
```

## 测试验证要求

### 1. 单元测试
- Service层业务逻辑测试
- Repository层数据访问测试
- 使用 `@SpringBootTest` 和 `@DataJpaTest`

### 2. 集成测试
- Controller层API测试
- 使用 `MockMvc` 测试HTTP请求
- 验证响应格式和状态码

### 3. 前端联调测试
- 启动后端服务：`mvn spring-boot:run`
- 访问 Swagger UI：`http://localhost:8080/swagger-ui/`
- 配合前端页面验证功能

## 常用代码片段

### 批量操作模板
```java
@Transactional
public BatchResult batchCreate(List<UserDTO> userDTOs) {
    BatchResult result = new BatchResult();
    List<User> users = new ArrayList<>();
    
    for (UserDTO dto : userDTOs) {
        try {
            User user = convertToEntity(dto);
            users.add(user);
            result.incrementSuccess();
        } catch (Exception e) {
            result.addError(dto.getUserName() + ": " + e.getMessage());
            result.incrementFailure();
        }
    }
    
    userRepository.saveAll(users);
    return result;
}
```

### 工作流状态转换
```java
public void updateWorkflowNodeStatus(Long nodeId, String status, String comment) {
    WorkflowNode node = workflowNodeRepository.findById(nodeId)
            .orElseThrow(() -> new BusinessException("节点不存在"));
    
    // 状态验证
    validateStatusTransition(node.getStatus(), status);
    
    // 更新状态
    node.setStatus(status);
    node.setComment(comment);
    node.setApprovedTime(LocalDateTime.now());
    
    workflowNodeRepository.save(node);
    
    // 记录审计日志
    auditLogService.log("WORKFLOW", "状态变更", 
            String.format("节点%s状态从%s变更为%s", nodeId, node.getStatus(), status));
}
```

## 性能优化建议

1. **数据库查询优化**
   - 使用 `@Query` 优化复杂查询
   - 添加适当的索引
   - 使用懒加载避免N+1问题

2. **缓存使用**
   - 使用 `@Cacheable` 缓存常用数据
   - Redis缓存在线用户信息
   - 缓存汇率等不常变动数据

3. **批量操作**
   - 使用 `saveAll()` 批量保存
   - 配置 Hibernate batch size
   - 大数据量使用分页处理

## 安全要求

1. **认证授权**
   - JWT Token认证
   - 接口权限控制
   - 敏感操作二次确认

2. **数据安全**
   - 密码BCrypt加密
   - SQL注入防护
   - XSS攻击防护

3. **审计追踪**
   - 所有操作记录日志
   - 登录登出追踪
   - 数据变更历史

## 部署注意事项

1. **环境变量配置**
   - 数据库连接信息
   - JWT密钥
   - 日志级别

2. **健康检查**
   - 实现 `/actuator/health` 端点
   - 数据库连接检查
   - 依赖服务检查

3. **监控指标**
   - API响应时间
   - 错误率统计
   - 资源使用情况

## 快速开发提示

1. **创建新模块时**：
   - 先设计数据库表结构
   - 创建实体类和DTO
   - 实现Repository接口
   - 编写Service业务逻辑
   - 开发Controller接口
   - 添加Swagger文档
   - 编写单元测试

2. **调试技巧**：
   - 开启SQL日志：`spring.jpa.show-sql=true`
   - 使用日志级别：`logging.level.demo.backed=DEBUG`
   - 查看Swagger UI测试接口

3. **常见问题解决**：
   - 跨域问题：检查SecurityConfig配置
   - 事务问题：确保Service方法有@Transactional
   - 序列化问题：检查DTO字段和JSON注解

记住：始终保持代码规范，注重测试覆盖，确保与前端数据格式一致！ 